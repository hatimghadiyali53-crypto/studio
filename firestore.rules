/**
 * @fileoverview Firestore Security Rules for Paradise ScoopSmart.
 *
 * Core Philosophy:
 * This ruleset prioritizes security by enforcing strict access control based on
 * user roles and explicit permissions. It assumes a closed-by-default posture,
 * where access is only granted if explicitly allowed by a rule.
 *
 * Data Structure:
 * The Firestore database is organized with top-level collections for each primary
 * entity: `employees`, `tasks`, `inventoryItems`, `roster`, and `attendance`.
 *
 * Key Security Decisions:
 * - Tasks are publicly readable but only authorized users can manage them.
 * - Other collections are secured with a default security posture of owner-only access.
 * - Schema validation is relaxed during prototyping, but critical relational
 *   fields are validated to maintain data consistency and prevent privilege escalation.
 *
 * Denormalization for Authorization:
 * To create simpler, more performant rules, important authorization data such as
 * ownership or role information must be denormalized directly onto the documents.
 *
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided user ID.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of an existing document.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user is the owner and the document exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }


    /**
     * @description Rules for the /employees collection.
     * @path /employees/{employeeId}
     * @allow (create) Authenticated user can create an employee profile if the employeeId matches their own user ID.
     * @deny (create) Authenticated user cannot create an employee profile if the employeeId does not match their own user ID.
     * @allow (get, list, update, delete) Authenticated user can only access and manage their own employee profile.
     * @deny (get, list, update, delete) Authenticated user cannot access or manage other employee profiles.
     * @principle Enforces document ownership for employee profiles and prevents unauthorized access.
     */
    match /employees/{employeeId} {
      allow create: if isSignedIn() && isOwner(employeeId) && request.resource.data.email == request.auth.token.email;
      allow get: if isOwner(employeeId);
      allow list: if false;
      allow update: if isExistingOwner(employeeId);
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Rules for the /tasks collection.
     * @path /tasks/{taskId}
     * @allow (get, list) Any user can read all tasks.
     * @allow (create) Only authenticated users can create tasks and must provide the correct assignedTo.
     * @deny (create) Unauthenticated users cannot create tasks.
     * @allow (update, delete) Only the user assigned to the task can update or delete it, provided the task exists.
     * @deny (update, delete) Other users cannot update or delete tasks.
     * @principle Allows public read access to tasks while restricting write access to authorized users.
     */
    match /tasks/{taskId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.assignedTo == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.assignedTo);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.assignedTo);
    }

    /**
     * @description Rules for the /inventoryItems collection.
     * @path /inventoryItems/{inventoryItemId}
     * @allow (create) Only authenticated users can create inventory items.
     * @deny (create) Unauthenticated users cannot create inventory items.
     * @allow (get, list, update, delete) Only authenticated users can access and manage inventory items.
     * @deny (get, list, update, delete) Other users cannot access or manage inventory items.
     */
    match /inventoryItems/{inventoryItemId} {
      allow create: if isSignedIn();
      allow get, list: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Rules for the /roster collection.
     * @path /roster/{rosterId}
     * @allow (create) Only authenticated users can create roster shifts.
     * @deny (create) Unauthenticated users cannot create roster shifts.
     * @allow (get, list, update, delete) Only authenticated users can access and manage roster shifts.
     * @deny (get, list, update, delete) Other users cannot access or manage roster shifts.
     */
    match /roster/{rosterId} {
        allow create: if isSignedIn();
        allow get, list: if isSignedIn();
        allow update: if isSignedIn();
        allow delete: if isSignedIn();
    }

    /**
     * @description Rules for the /attendance collection.
     * @path /attendance/{attendanceId}
     * @allow (create) Only authenticated users can create attendance records.
     * @deny (create) Unauthenticated users cannot create attendance records.
     * @allow (get, list, update, delete) Only authenticated users can access and manage attendance records.
     * @deny (get, list, update, delete) Other users cannot access or manage attendance records.
     */
    match /attendance/{attendanceId} {
        allow create: if isSignedIn();
        allow get, list: if isSignedIn();
        allow update: if isSignedIn();
        allow delete: if isSignedIn();
    }
  }
}